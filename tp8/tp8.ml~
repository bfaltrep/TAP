(* - Ex1 - *)

(* Q1 - evaluation paresseuse *)

type 'a frozen_flow = 
| End of 'a
| Step of (unit -> 'a frozen_flow);;

(* reconnait pas x comme une function meme si il est Step *)
let thaw x =
  match x with
  | End y -> End y
  | Step f -> f ();;

(* Q2 *)

let ppcm x y =
  let rec ppcm_rec x y mul = 
    if (y > x) then (ppcm_rec y x mul) else (* Ensures x >= y *)
    if (x = 0) then 0 else                  (* Ensures both are positive *)
      let r = (x mod y) in 
        if (r = 0) then (mul/y) else ppcm_rec y r mul
  in ppcm_rec x y (x*y);;


(* wanted : int -> int -> int frozen_flow*)
let frozen_ppcm x y =
  let rec ppcm_rec x y mul = 
    if (y > x) then Step (fun () -> ppcm_rec y x mul) else (* Ensures x >= y *)
      if (x = 0) then End 0 else                  (* Ensures both are positive *)
	let r = (x mod y) in 
        if (r = 0) then End (mul/y) else Step (fun () -> ppcm_rec y r mul)
  in ppcm_rec x y (x*y);;

(* Q3 *)

type ('key,'data) frozen_data_flow = 
| End of 'data
| Step of (unit -> (('key*'data) list) * ('key,'data) frozen_data_flow);;

let thaw x =
  match x with
  | End y -> End y
  | Step f -> f ();;

(* result : val frozen_ppcm_assoc : int -> int -> (string, int) frozen_data_flow = <fun> *)
let frozen_ppcm_assoc x y =
  let rec ppcm_rec x y mul = 
    if (y > x) then Step (fun () -> ( [("x",x);("y",y);("mul",mul)], ppcm_rec y x mul )) else (* Ensures x >= y *)
      if (x = 0) then End 0 else                  (* Ensures both are positive *)
	let r = (x mod y) in 
        if (r = 0) then End (mul/y) else Step (fun () -> ( [("x",x);("y",y);("mul",mul)] , ppcm_rec y r mul))
  in ppcm_rec x y (x*y);;

(* - Ex2 - Lazy lib *)

let f = lazy (failwith "Marchera pas");;
Lazy.force f;;

(* Q1 *)

(* congeler *)
let entier = (End 5);;
let liste = (End [2;5;4;5;8;9]);;
let tableau = (End [|2;5;4;5;8;9|]);;
(* decongeler *)
let unfrozen value = lazy value;;

(* Q2 *)

let bord_effect x = print_int x;;

let frozen = lazy (bord_effect 5);;
let unfrozen = Lazy.force frozen;;

(* l'effet de bord se produit lorsqu'on 'décongèle' la fonction *)

(* Q3 *)

(* on constate qu'on ne peut utiliser unfrozen qu'une seule fois alors que dans la version de l'exercice 1, la définition de 'unfrozen' fait qu'on peut l'utiliser autant de fois que l'on veut. *)

(* - Ex3 - Flots de données *)

(* Q1 *)

type 'a stm1 = 
| Stm1Empty 
| Cons1 of 'a * ('a stm1 lazy_t)
