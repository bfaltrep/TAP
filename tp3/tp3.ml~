(* Ex1 - curry*)

(* Q1 *)
let f1 (a, b, c) = b;;

(* Q2 *)
let testc x y = x+y;;
let testdec (x, y) = x+y;;

let curry f x y = f (x,y);;
let decurry f (x,y) = f x y;;

let testc_decur = decurry testc;;
let testdec_cur = curry testdec;;

testc_decur (4,5);;
testdec_cur 4 5;;

(* Q3 *)

let inverse f x y = f y x ;;                          

(* Q4 *)

let test x = x*2;;

(* REFAIRE - pas assez générique*)
let iterate f n = if n<1
  then 1
  else f (f(n-1));;

(* Ex2 -liste *)
(*
  'a list => liste de type générique.
  1::[];; <= concatene
 - : int list = [1]

  [ (1,"true")  ; (2,"false") ] => liste de tuples (tuples du MEME format)

*)

let list = 4::5::7::[];;
let rec voir l =
  match l with
    | [] -> print_string " "
    | t::q -> print_int t; print_string " ";
              voir q;;

let list = [(1,"v");(2,"a");(4,"n");(2,"z")];;
let rec list_remove l i =
  let getkey (a,b) = a in
  match l with
    | [] -> []
    | t::q -> if (getkey(t)=i)
               then list_remove q i
               else t::list_remove q i;;

let rec list_map f l =
  match l with
    | [] -> []
    | t::q -> (f t)::list_map f q;;


let list = 4::5::7::[];;
let list2 = 1::2::3::[];;

let rec list_concat_term l1 l2 =
  match l2 with
    | [] -> l1;
    | t::q -> list_concat_term t::l1 q;;
